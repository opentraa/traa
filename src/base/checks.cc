/*
 *  Copyright 2006 The WebRTC Project Authors. All rights reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree. An additional intellectual property rights grant can be found
 *  in the file PATENTS.  All contributing project authors may
 *  be found in the AUTHORS file in the root of the source tree.
 */

// Most of this was borrowed (with minor modifications) from V8's and Chromium's
// src/base/logging.cc.

#include "base/platform.h"

#include <cstdarg>
#include <cstdio>
#include <cstdlib>

#if defined(TRAA_OS_LINUX_ANDROID)
#define TRAA_LOG_TAG_ANDROID "traa"
#include <android/log.h> // NOLINT
#endif

#if defined(TRAA_OS_WINDOWS)
#include <windows.h>
#endif

#if defined(TRAA_OS_WINDOWS)
#define LAST_SYSTEM_ERROR (::GetLastError())
#elif defined(__native_client__) && __native_client__
#define LAST_SYSTEM_ERROR (0)
#elif defined(TRAA_OS_POSIX)
#include <errno.h>
#define LAST_SYSTEM_ERROR (errno)
#endif // TRAA_OS_WINDOWS

#include "base/checks.h"

namespace {

#if defined(__GNUC__)
__attribute__((__format__(__printf__, 2, 3)))
#endif
void append_format(std::string* s, const char* fmt, ...) {
  va_list args, copy;
  va_start(args, fmt);
  va_copy(copy, args);
  const int predicted_length = std::vsnprintf(nullptr, 0, fmt, copy);
  va_end(copy);

  if (predicted_length > 0) {
    const size_t size = s->size();
    s->resize(size + predicted_length);
    // Pass "+ 1" to vsnprintf to include space for the '\0'.
    std::vsnprintf(&((*s)[size]), predicted_length + 1, fmt, args);
  }
  va_end(args);
}
} // namespace

namespace traa {
namespace base {

namespace checks_impl {

TRAA_NORETURN void write_fatal_log(std::string_view output) {
#if defined(TRAA_OS_LINUX_ANDROID)
  std::string output_str(output);
  __android_log_print(ANDROID_LOG_ERROR, TRAA_LOG_TAG_ANDROID, "%s\n", output_str.c_str());
#endif
  fflush(stdout);
  fwrite(output.data(), output.size(), 1, stderr);
  fflush(stderr);
#if defined(TRAA_OS_WINDOWS)
  DebugBreak();
#endif
  abort();
}

TRAA_NORETURN void write_fatal_log(const char * /* file */, int /* line */,
                                   std::string_view output) {
  write_fatal_log(output);
}

#if TRAA_CHECK_MSG_ENABLED
// Reads one argument from args, appends it to s and advances fmt.
// Returns true iff an argument was sucessfully parsed.
bool parse_arg(va_list *args, const check_arg_type **fmt, std::string *s) {
  if (**fmt == check_arg_type::t_end)
    return false;

  switch (**fmt) {
  case check_arg_type::t_int:
    append_format(s, "%d", va_arg(*args, int));
    break;
  case check_arg_type::t_long:
    append_format(s, "%ld", va_arg(*args, long));
    break;
  case check_arg_type::t_long_long:
    append_format(s, "%lld", va_arg(*args, long long));
    break;
  case check_arg_type::t_uint:
    append_format(s, "%u", va_arg(*args, unsigned));
    break;
  case check_arg_type::t_ulong:
    append_format(s, "%lu", va_arg(*args, unsigned long));
    break;
  case check_arg_type::t_ulong_long:
    append_format(s, "%llu", va_arg(*args, unsigned long long));
    break;
  case check_arg_type::t_double:
    append_format(s, "%g", va_arg(*args, double));
    break;
  case check_arg_type::t_long_double:
    append_format(s, "%Lg", va_arg(*args, long double));
    break;
  case check_arg_type::t_char_p:
    s->append(va_arg(*args, const char *));
    break;
  case check_arg_type::t_std_string:
    s->append(*va_arg(*args, const std::string *));
    break;
  case check_arg_type::t_string_view: {
    const std::string_view sv = *va_arg(*args, const std::string_view *);
    s->append(sv.data(), sv.size());
    break;
  }
  case check_arg_type::t_void_p:
    append_format(s, "%p", va_arg(*args, const void *));
    break;
  default:
    s->append("[invalid check_arg_type]");
    return false;
  }
  (*fmt)++;
  return true;
}

TRAA_NORETURN void fatal_log(const char *file, int line, const char *message,
                             const check_arg_type *fmt, ...) {
  va_list args;
  va_start(args, fmt);

  std::string s;
  append_format(&s,
                "\n\n"
                "#\n"
                "# fatal error in: %s, line %d\n"
                "# last system error: %u\n"
                "# check failed: %s",
                file, line, LAST_SYSTEM_ERROR, message);

  if (*fmt == check_arg_type::t_check_op) {
    // This log message was generated by TRAA_CHECK_OP, so we have to complete
    // the error message using the operands that have been passed as the first
    // two arguments.
    fmt++;

    std::string s1, s2;
    if (parse_arg(&args, &fmt, &s1) && parse_arg(&args, &fmt, &s2))
      append_format(&s, " (%s vs. %s)\n# ", s1.c_str(), s2.c_str());
  } else {
    s.append("\n# ");
  }

  // Append all the user-supplied arguments to the message.
  while (parse_arg(&args, &fmt, &s))
    ;

  va_end(args);

  write_fatal_log(file, line, s);
}
#else  // TRAA_CHECK_MSG_ENABLED
TRAA_NORETURN void fatal_log(const char *file, int line) {
  std::string s;
  append_format(&s,
                "\n\n"
                "#\n"
                "# fatal error in: %s, line %d\n"
                "# last system error: %u\n"
                "# check failed.\n"
                "# ",
                file, line, LAST_SYSTEM_ERROR);
  write_fatal_log(file, line, s);
}
#endif // TRAA_CHECK_MSG_ENABLED

#if TRAA_DCHECK_IS_ON

TRAA_NORETURN void unreachable_code_reached(const char *file, int line) {
  std::string s;
  append_format(&s,
                "\n\n"
                "#\n"
                "# unreachable code reached: %s, line %d\n"
                "# last system error: %u\n"
                "# ",
                file, line, LAST_SYSTEM_ERROR);
  write_fatal_log(file, line, s);
}

#else // !TRAA_DCHECK_IS_ON

TRAA_NORETURN void unreachable_code_reached() {
  std::string s;
  append_format(&s,
                "\n\n"
                "#\n"
                "# unreachable code reached (file and line unknown)\n"
                "# last system error: %u\n"
                "# ",
                LAST_SYSTEM_ERROR);
  write_fatal_log(s);
}

#endif // !TRAA_DCHECK_IS_ON

} // namespace checks_impl

} // namespace base
} // namespace traa

// Function to call from the C version of the TRAA_CHECK and TRAA_DCHECK macros.
TRAA_NORETURN void fatal_message(const char *file, int line, const char *msg) {
#if TRAA_CHECK_MSG_ENABLED
  static constexpr traa::base::checks_impl::check_arg_type t[] = {
      traa::base::checks_impl::check_arg_type::t_end};
  traa::base::checks_impl::fatal_log(file, line, msg, t);
#else
  traa::base::checks_impl::fatal_log(file, line);
#endif
}
